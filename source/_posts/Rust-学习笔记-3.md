---
title: Rust 学习笔记 3
date: 2020-03-30 23:39:35
tags:
- rust
---

阅读 [《 Rust 程序设计》](https://doc.rust-lang.org/book)的一些笔记。

数据类型。

<!--more-->

## 标量类型（scalar types）

### 整数类型

整数类型有： 
`i8`, `i16`, `i32`, `i64`, `i128`, `isize`,
`u8`, `u16`, `u32`, `u64`, `u128`, `usize`。

Rust 的默认整数类型是 `i32` ，即使在 64 位系统上，这种类型通常也是最快的。

使用 `isize` 或 `usize` 的主要用在对某种集合进行索引的场景。

> 整数溢出，在 debug 模式编译的程序遇到整数溢出问题会 panic， release 模式编译则不 panic ，而是进行两个补码换行，例如 `u8` 类型保存 256 会变成 0， 保存 257 会变成 1 ，以此类推。依赖整数移除的 wrapping 行为被视为错误，如果要显式 wrap ，则可以使用标准库类型 `Wrapping` 。

### 浮点类型

浮点类型有： `f32`, `f64`。

默认类型为 `f64` ，因为在现代 CPU 上，它的速度与 `f32` 大致相同，但精度更高。

### 数字运算

Rust 支持四则运算和求余运算。

附录 B 中列出了更多运算符。

### 布尔类型

布尔值只要用于条件表达式，比如 `if` 表达式。

### 字符类型

`char` 类型是 Rust 中最基本的字母类型，使用单引号指定。（相对的字符串文字，使用双引号。）

Rust 中 `char` 类型，大小为 4 字节，代表 Unicode 标量。Unicode 标量值范围从 `U+0000` 至 `U+D7FF` 和 `U+E000` 至 `U+10FFFF` 。但是 “字符” 并不是 Unicode 中真正的概念，因此你对 “字符” 的直觉可能与 Rust 中不一致。我们在第 8 章中讨论。

## 复合类型

复合类型可以组合多个值到一个类型中， Rust 有两个基本复合类型： 元组（tuples）和数组（arrays）

### 元组类型

元组是一种将多种类型的值组合为一个复合类型的一般方法。元组的长度是固定的：声明之后它们的长度就无法增长或缩小。

我们在括号内编写逗号分隔的值列表来创建元组。元组中每个位置都有一个类型，并且元组中不通知的类型不必相同，此例中，我们添加了可选的类型注释：

```rust
let tup: (i32, f64, u8) = (1, 1.1, 1);
```

元组可以通过和 `let` 的一种模式解构（destructuring）。

```rust
fn main() {
    let tup = (1, 2, 3.1);
    let (_, y, _) = tup;
    println!("The value of y is {}", y);
}
```

除了通过模式匹配进行解构，我们还是可以通过点号（.）加索引的方式访问元组元素。例如：

```rust
fn main() {
    let x = (1, 2.1, 3);
    println!("{} {} {}", x.0, x.1, x.2);
}
```

### 数组类型

数组中的元素类型必须相同， Rust 中的数组具有固定长度。

放入数组的值被写成用方括号括起来的都好分隔的列表。

当你想把数据分配在栈上而不是堆上时，数组很有用。（第 4 章中讨论堆栈）

数组不如向量类型（vector type）灵活。虽然，向量是标准库提供的类似集合类型，允许大小缩放。如果不确定使用数组还是向量，则可能就该使用向量。第 8 章细谈向量。

一个使用数组而不是向量的例子：程序中需要知道每个月份的名称，这样的程序不太可能增加或删除月份，这样你可以使用数组，因为你知道它始终包含 12 个元素。

初始化给数组赋值的方式：

```rust
// [类型; 长度] 
let a: [i32; 5] = [1, 2, 3, 4, 5];

// [初始值; 长度]
let a = [3; 5]; 
// 等同于
let a = [3, 3, 3, 3, 3];
```

#### 访问数组元素

数组是栈上分配的单一内存块。你可以通过索引访问数组元素，如下：

```rust
fn main() {
    let a = [1, 2, 3, 4];
    let first = a[0];
    let second = a[1];
}
```

#### 无效的数组元素访问

如果你尝试访问超出数组末尾的数组元素会如何？下面的程序可以通过编译，但是运行会报 panic ：

```rust
fn main() {
    let a = [1, 2, 4];
    let index = 5;
    let element = a[index];
}
```

第 9 章讨论错误处理。
