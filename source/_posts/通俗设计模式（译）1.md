---
title: 通俗设计模式（译）1
date: 2020-04-24 15:57:09
tags:
- translation
- design pattern
---

[原文：Design Patterns for Humans](https://roadmap.sh/guides/design-patterns-for-humans)

接上一篇，本章关于结构设计模式。

<!--more-->

## 结构设计模式

简而言之

> 结构模式主要与对象组成有关，换句话说，实体如何互相利用。或者还有另一种解释，它们有助于回答“如何构建软件组件？”。

维基说

> 在软件工程中，结构设计模式是通过识别实体间的简单方法来简化设计的设计模式。

这有 7 种结构模式：

- [Adapter 适配器](#🔌-适配器)
- [Bridge 桥接](#🚡-桥接)
- [Composite 组合](#🌿-组合)
- [Decorator 装饰器](#☕-装饰器)
- [Facade 外观](#📦-外观模式)
- [Flyweight](#🍃-flyweight)
- [Proxy 代理](#🎱-代理)

### 🔌 适配器

现实例子

> 在你的存储卡中有一些照片，需要将它们传输到计算机上。为了传输它们，你需要某种和计算机端口兼容的适配器，以便将存储卡连接到计算机。这种情况下，读卡器就是适配器。另一个例子是著名的电源适配器，三脚插头不能连接到两脚插座，需要使用电源适配器，使其与两脚插座兼容。还有个例子是翻译员将一个人说的话翻译给另一个人。

简而言之

> 适配器模式是你可以将其他不兼容的对象包装到适配器中，以使其与另一个类兼容。

维基说

> 软件工程领域，适配器模式是一种软件设计模式，它允许将现有类的接口用作另一个接口。它通常用于将现有类和其他类一起使用而无需修改其源代码。

**程序示例**

思考一个猎人狩猎狮子的游戏。首先我们有一个 `Lion` 接口，所有类型的狮子都必须实现。

```php
interface Lion
{
    public function roar();
}

class AfricanLion implements Lion
{
    public function roar()
    {
    }
}

class AsianLion implements Lion
{
    public function roar()
    {
    }
}
```

猎人使用 `Lion` 接口的任何实现都可以进行狩猎。

```php
class Hunter
{
    public function hunt(Lion $lion)
    {
        $lion->roar();
    }
}
```

现在假设我们必须在游戏中添加 WildDog （野狗），以便猎人对其狩猎。但是我们不能直接这样做，因为狗具有不同的接口。为了使其与我们的猎人兼容，我们必须创建一个兼容的适配器。

```php
// 把它添加到游戏。
class WildDog
{
    public function bark()
    {
    }
}

// 关于野狗的适配器，使其与我们的游戏兼容。
class WildDogAdapter implements Lion
{
    protected $dog;

    public function __construct(WildDog $dog)
    {
        $this->dog = $dog;
    }

    public function roar()
    {
        $this->dog->bark();
    }
}
```

现在可以使用 WildDogAdapter 在我们的游戏中使用 WildDog 了。

```php
$wildDog = new WildDog();
$wildDogAdapter = new WildDogAdapter($wildDog);

$hunter = new Hunter();
$hunter->hunt($wildDogAdapter);
```

### 🚡 桥接

现实例子

> 考虑你有一个包含不同页面的网站，并且允许用户更改主题。你会怎么做？为每个主题创建每个页面的多个副本，还是只创建单独的主题，根据用户的喜好加载它们？桥接模式允许你执行第二种方案。

![Without Bridge](33b7aea0-f515-11e6-983f-98823c9845ee.png)

简而言之

> 桥接模式是优先于继承而不是继承。将实现细节从层次结构推送到具有单独层次结构的另一个对象。

维基说

> 桥接模式是软件工程中使用的一种设计模式，旨在“将抽象与其实现分离，从而使两者可以独立变化”。

**程序示例**

转换上面 WebPage 的例子。这是 WebPage 的层次结构。

```php
interface WebPage
{
    public function __construct(Theme $theme);
    public function getContent();
}

class About implements WebPage
{
    protected $theme;

    public function __construct(Theme $theme)
    {
        $this->theme = $theme;
    }

    public function getContent()
    {
        return "About page in " . $this->theme->getColor();
    }
}

class Careers implements WebPage
{
    protected $theme;

    public function __construct(Theme $theme)
    {
        $this->theme = $theme;
    }

    public function getContent()
    {
        return "Careers page in " . $this->theme->getColor();
    }
}
```

以及单独主题的层次结构

```php
interface Theme
{
    public function getColor();
}

class DarkTheme implements Theme
{
    public function getColor()
    {
        return 'Dark Black';
    }
}
class LightTheme implements Theme
{
    public function getColor()
    {
        return 'Off white';
    }
}
class AquaTheme implements Theme
{
    public function getColor()
    {
        return 'Light blue';
    }
}
```

两个层次的用法

```php
$darkTheme = new DarkTheme();

$about = new About($darkTheme);
$careers = new Careers($darkTheme);

echo $about->getContent(); // "About page in Dark Black";
echo $careers->getContent(); // "Careers page in Dark Black";
```

### 🌿 组合

现实例子

> 每一个组织由雇员组成。每个受雇者有相同功能，比如，有一份薪水、一些职责、是否向某人报告、是否有下属等等。

简而言之

> 组合模式使客户能够以统一的方式对待各个对象。

维基说

> 在软件工程中，组合模式是一种分区设计模式。组合模式将一组对象当成一个对象的单个实例对待。组合的目的是将对象“组成”树状结构，以表示整个部分的层次结构。实现组合模式可以使客户统一对待单个对象和复合对象。

**程序示例**

以我们的雇员为例。这里有不同的员工类型。

```php
interface Employee
{
    public function __construct(string $name, float $salary);
    public function getName(): string;
    public function setSalary(float $salary);
    public function getSalary(): float;
    public function getRoles(): array;
}

class Developer implements Employee
{
    protected $salary;
    protected $name;
    protected $roles;
    
    public function __construct(string $name, float $salary)
    {
        $this->name = $name;
        $this->salary = $salary;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setSalary(float $salary)
    {
        $this->salary = $salary;
    }

    public function getSalary(): float
    {
        return $this->salary;
    }

    public function getRoles(): array
    {
        return $this->roles;
    }
}

class Designer implements Employee
{
    protected $salary;
    protected $name;
    protected $roles;

    public function __construct(string $name, float $salary)
    {
        $this->name = $name;
        $this->salary = $salary;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setSalary(float $salary)
    {
        $this->salary = $salary;
    }

    public function getSalary(): float
    {
        return $this->salary;
    }

    public function getRoles(): array
    {
        return $this->roles;
    }
}
```

然后我们有一个由几种不同类型雇员组成的组织。

```php
class Organization
{
    protected $employees;

    public function addEmployee(Employee $employee)
    {
        $this->employees[] = $employee;
    }

    public function getNetSalaries(): float
    {
        $netSalary = 0;

        foreach ($this->employees as $employee) {
            $netSalary += $employee->getSalary();
        }

        return $netSalary;
    }
}
```

接着这么用

```php
// 准备员工
$john = new Developer('John Doe', 12000);
$jane = new Designer('Jane Doe', 15000);

// 把他们添加到组织
$organization = new Organization();
$organization->addEmployee($john);
$organization->addEmployee($jane);

echo "Net salaries: " . $organization->getNetSalaries(); // Net Salaries: 27000
```

### ☕ 装饰器

现实例子

> 假设你经营一家提供多种服务的汽车维修店。现在，你要如何计算要收取的账单？选择一项服务，并动态地向其添加服务和的价格，知道获得最终花销。这里的每种服务都是装饰器。

简而言之

> 装饰器模式使你可以将对象包装在装饰器类的对象中，从而在运行时动态更改对象的行为。

维基说

> 面向对象编程中，装饰器模式是一种设计模式，它允许将行为动态或静态地添加到单个对象中，而不影响同一类中其他对象地行为。装饰器模式通常可用于遵守“单一职责原则”，因为它允许在具有唯一关注区域的类之间划分功能。

**程序示例**

以咖啡为例，首先，我们有个简单的 offee 的接口及实现。

```php
interface Coffee
{
    public function getCost();
    public function getDescription();
}

class SimpleCoffee implements Coffee
{
    public function getCost()
    {
        return 10;
    }

    public function getDescription()
    {
        return 'Simple coffee';
    }
}
```

我们希望使代码可扩展，以便在需要时通过选项配置，我们为其添加装饰器。

```php
class MilkCoffee implements Coffee
{
    protected $coffee;

    public function __construct(Coffee $coffee)
    {
        $this->coffee = $coffee;
    }

    public function getCost()
    {
        return $this->coffee->getCost() + 2;
    }

    public function getDescription()
    {
        return $this->coffee->getDescription() . ', milk';
    }
}

class WhipCoffee implements Coffee
{
    protected $coffee;

    public function __construct(Coffee $coffee)
    {
        $this->coffee = $coffee;
    }

    public function getCost()
    {
        return $this->coffee->getCost() + 5;
    }

    public function getDescription()
    {
        return $this->coffee->getDescription() . ', whip';
    }
}

class VanillaCoffee implements Coffee
{
    protected $coffee;

    public function __construct(Coffee $coffee)
    {
        $this->coffee = $coffee;
    }

    public function getCost()
    {
        return $this->coffee->getCost() + 3;
    }

    public function getDescription()
    {
        return $this->coffee->getDescription() . ', vanilla';
    }
}
```

现在来制作咖啡。

```php
$someCoffee = new SimpleCoffee();
echo $someCoffee->getCost(); // 10
echo $someCoffee->getDescription(); // Simple Coffee

$someCoffee = new MilkCoffee($someCoffee);
echo $someCoffee->getCost(); // 12
echo $someCoffee->getDescription(); // Simple Coffee, milk

$someCoffee = new WhipCoffee($someCoffee);
echo $someCoffee->getCost(); // 17
echo $someCoffee->getDescription(); // Simple Coffee, milk, whip

$someCoffee = new VanillaCoffee($someCoffee);
echo $someCoffee->getCost(); // 20
echo $someCoffee->getDescription(); // Simple Coffee, milk, whip, vanilla
```

### 📦 外观模式

现实例子

> 你是怎么打开计算机的？“按下电源按钮”你会这么说，那仅仅是你所知道的，那是你使用的计算机在外部提供的简单接口，在内部，它还必须要做很多事情才能实现。与复杂子系统的这种简单接口就是一个外观。

简而言之

> 外观模式提供了到复杂子系统的简化接口。

维基说

> 外观是为大型代码（例如类库）提供简化接口的对象。

**程序示例**

用上面计算机的例子，这里有个计算机类。

```php
class Computer
{
    public function getElectricShock()
    {
        echo "Ouch!";
    }

    public function makeSound()
    {
        echo "Beep beep!";
    }

    public function showLoadingScreen()
    {
        echo "Loading..";
    }

    public function bam()
    {
        echo "Ready to be used!";
    }

    public function closeEverything()
    {
        echo "Bup bup bup buzzzz!";
    }

    public function sooth()
    {
        echo "Zzzzz";
    }

    public function pullCurrent()
    {
        echo "Haaah!";
    }
}
```

这是外观。

```php
class ComputerFacade
{
    protected $computer;

    public function __construct(Computer $computer)
    {
        $this->computer = $computer;
    }

    public function turnOn()
    {
        $this->computer->getElectricShock();
        $this->computer->makeSound();
        $this->computer->showLoadingScreen();
        $this->computer->bam();
    }

    public function turnOff()
    {
        $this->computer->closeEverything();
        $this->computer->pullCurrent();
        $this->computer->sooth();
    }
}
```

使用外观。

```php
$computer = new ComputerFacade(new Computer());
$computer->turnOn(); // Ouch! Beep beep! Loading.. Ready to be used!
$computer->turnOff(); // Bup bup buzzz! Haah! Zzzzz
```

### 🍃 flyweight

现实例子

> 你有没有在摊子上买过茶？他们通常会多做几杯，把多出来的留给其他顾客，这样可以节约资源，比如燃气。 flyweight 设计模式主要就是这里，即共享。

简而言之

> 它用于通过与相似对象尽可能多地共享来最大程度减少内存使用或者计算开销。

维基说

> 在计算机编程中，flyweight 是一种软件设计模式。flyweight 是通过与其他类似对象共享尽可能多的数据来最大程度减少内存使用的对象；当简单的重复代码占用了过多内存时，这是一种大量使用对象的方法。

**程序示例**

利用上面茶的例子。首先要有做茶师傅。

```php
// Anything that will be cached is flyweight.
// Types of tea here will be flyweights.
class KarakTea
{
}

// Acts as a factory and saves the tea
class TeaMaker
{
    protected $availableTea = [];

    public function make($preference)
    {
        if (empty($this->availableTea[$preference])) {
            $this->availableTea[$preference] = new KarakTea();
        }

        return $this->availableTea[$preference];
    }
}
```

接着是提供服务的茶店（TeaShop）

```php
class TeaShop
{
    protected $orders;
    protected $teaMaker;

    public function __construct(TeaMaker $teaMaker)
    {
        $this->teaMaker = $teaMaker;
    }

    public function takeOrder(string $teaType, int $table)
    {
        $this->orders[$table] = $this->teaMaker->make($teaType);
    }

    public function serve()
    {
        foreach ($this->orders as $table => $tea) {
            echo "Serving tea to table# " . $table;
        }
    }
}
```

用法

```php
$teaMaker = new TeaMaker();
$shop = new TeaShop($teaMaker);

$shop->takeOrder('less sugar', 1);
$shop->takeOrder('more milk', 2);
$shop->takeOrder('without sugar', 5);

$shop->serve();
// Serving tea to table# 1
// Serving tea to table# 2
// Serving tea to table# 5
```

### 🎱 代理

实际例子

> 用过门禁卡通过安全门吗？开门的方法很多，比如用门禁卡或者按下绕过安全性的按钮。门的主要功能是打开，但是其顶部添加了代理以添加一些功能。让我使用下面的代码示例解释它。

简而言之

> 使用代理模式，一个类表示另一个类的功能。

维基说

> 一般来说，代理是一个类，充当其他类的接口。代理时客户端调用的包装器或者包装对象，用来访问后台的真实对象。使用代理可以简单地转发到真实对象，还可以提供其他逻辑。在代理中，还可以提供额外的功能，例如在对实际对象地操作占用大量资源时进行缓存，或者在调用对真是对象地操作之前检查先决条件。

**程序示例**

用上面安全门的例子。首先，实现门的接口。

```php
interface Door
{
    public function open();
    public function close();
}

class LabDoor implements Door
{
    public function open()
    {
        echo "Opening lab door";
    }

    public function close()
    {
        echo "Closing the lab door";
    }
}
```

接着我们用一个代理使门更安全

```php
class SecuredDoor
{
    protected $door;

    public function __construct(Door $door)
    {
        $this->door = $door;
    }

    public function open($password)
    {
        if ($this->authenticate($password)) {
            $this->door->open();
        } else {
            echo "Big no! It ain't possible.";
        }
    }

    public function authenticate($password)
    {
        return $password === '$ecr@t';
    }

    public function close()
    {
        $this->door->close();
    }
}
```

用例

```php
$door = new SecuredDoor(new LabDoor());
$door->open('invalid'); // Big no! It ain't possible.

$door->open('$ecr@t'); // Opening lab door
$door->close(); // Closing lab door
```

另一个例子是某种数据映射器的实现。例如，我最近使用这种模式为 MongoDB 制作了 ODM (对象数据映射器)，在其中用到了魔法方法 `__call()` 围绕 mongo 类编写了一个代理。所有的方法调用都被代理到原始 mongo 类，并且原样返回检索结果，但是 `find` 或 `findOne` 的情况下，数据映射到所需的类对象，返回的是该对象而不是 `Cursor`。
