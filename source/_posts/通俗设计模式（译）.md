---
title: 通俗设计模式（译）0
date: 2020-04-23 20:43:42
tags:
- translation
- design pattern
---

[原文：Design Patterns for Humans](https://roadmap.sh/guides/design-patterns-for-humans)

设计模式是对反复出现的问题的解决方案；*解决某些问题的指南*。它们不是像魔法一样的类、包或者库。这个指南说的是在某些情况下如何解决某些问题。

<!--more-->

> 设计模式是对反复出现的问题的解决方案。如何解决某些问题的指南。

Wikipedia 的描述如下：

> 在软件工程领域，软件设计模式是对软件设计中给定上下文中常见问题的通用可重用解决方案。它不是可以直接转换为源代码或机器码的最终设计。它是一种描述或模板，用于在许多不同情况下解决问题。

## 小心

开发人员（大多是初学者）犯了过分思考和强加设计模式的错误，这可能会导致灾难。经验法则是使代码库尽可能简单，一旦开始开发，你就能在代码库中看到重复模式时，再执行相关设计模式。

- 设计模式不是银弹。（译注：银弹指的是万能工具）
- 不要强行使用，不然有好果子吃。
- 请记住，设计模式是*解决*问题的方法，而不是*发现*问题的方案，不要想太多。
- 用得对时被称为救星，不然就是代码混乱。

> 代码示例用 PHP-7 编写，但丝毫不影响你理解概念。

## 设计模式的类型

本指南关于 Gang of Four (Gof) 设计模式，命名来自[介绍了这些设计模式的这本书的四位作者](https://en.wikipedia.org/wiki/Design_Patterns)。这有三种设计模式：

- [Creational](#创建设计模式) （创建）
- [Structural](/2020/04/24/通俗设计模式（译）1) （结构）
- [Behavioral](/2020/04/25/通俗设计模式（译）2) （行为）

## 创建设计模式

简而言之

> 创建模式专注于如何实例化一个对象或一组对象。

Wiki 百科说：

> 软件工程领域，创建设计模式时处理对象创建机制的设计模式，尝试以适合的方式创建对象。对象创建的基本形式可能会导致设计问题或者增加设计的复杂性。创建设计模式通过某种方法控制对象的创建来解决此问题。

这里有 6 类创建模式：

- [Simple Factory 简单工厂](#🏠-简单工厂) 
- [Factory Method 工厂方法](#🏭-工厂方法) 
- [Abstract Factory 抽象工厂](#🔨-抽象工厂) 
- [Builder 建造者](#👷-建造者) 
- [Prototype 原型](#🐑-原型) 
- [Singleton 单例](#💍-单例) 

### 🏠 简单工厂

现实例子

> 考虑一下，你在盖房子，需要门。你可以穿上木匠衣服，带上木头、胶水、钉子和所有必要的扇门工具，然后开始在房子造门。或者你只要打个电话给工厂，然后他们把造好的门给你，这样你就不需要了解任何造门的额外知识了。

简而言之

> 简单工厂只需要为使用者生成一个实例，而不需要为使用者公开任何实例化的逻辑。

维基说

> 面向对象编程（OOP）中，工厂时用于创建其他对象的对象 —— 正式说法是，工厂是一种函数或方法，它从某个方法（假定为 “new”）调用并返回不同原型或类的对象。

**程序示例**

首先我们有个门的接口和其实现

```php
interface Door
{
    public function getWidth(): float;
    public function getHeight(): float;
}

class WoodenDoor implements Door
{
    protected $width;
    protected $height;

    public function __construct(float $width, float $height)
    {
        $this->width = $width;
        $this->height = $height;
    }

    public function getWidth(): float
    {
        return $this->width;
    }

    public function getHeight(): float
    {
        return $this->height;
    }
}
```

然后我们有个门工厂来制造门并返回它

```php
class DoorFactory
{
    public static function makeDoor($width, $height): Door
    {
        return new WoodenDoor($width, $height);
    }
}
```

然后就可以这样用

```php
// 给我造一扇 100*200 尺寸的门
$door = DoorFactory::makeDoor(100, 200);

echo 'Width: ' . $door->getWidth();
echo 'Height: ' . $door->getHeight();

// 给我造一扇 50*100 尺寸的门
$door2 = DoorFactory::makeDoor(50, 100);
```

**啥时候用呢？**

创建对象时，不仅要复制，还要执行一些逻辑操作，这些代码放到专门的“工厂”里相比四处复制粘贴相同代码是更有意义的。

### 🏭 工厂方法

现实例子

> 思考一个招聘经理的例子，一个人不可能对每个职位进行面试。根据职位空缺，她必须决定面试步骤然后将其委托给其他人。

简而言之

> 它提供了一种将实例化逻辑委托给子类的方法。

维基说

> 基于类的编程中，工厂方法模式是一种创建模式，该模式使用工厂方法来处理创建对象的问题，而不必指定将要创建对象的确切类。这是通过调用工厂方法创建对象来完成的。该方法在接口中指定并又子类实现，或者在基类中实现，并且可以选择由派生类覆盖，而不是通过调用构造函数来覆盖。

**程序示例**

以我们上文的招聘经理为例。首先，我们有一个面试官接口及其实现

```php
interface Interviewer
{
    public function askQuestions();
}

class Developer implements Interviewer
{
    public function askQuestions()
    {
        echo 'Asking about design patterns!';
    }
}

class CommunityExecutive implements Interviewer
{
    public function askQuestions()
    {
        echo 'Asking about community building';
    }
}
```

现在造一个招聘经理（HiringManager）

```php
abstract class HiringManager
{

    // 工厂方法
    abstract protected function makeInterviewer(): Interviewer;

    public function takeInterview()
    {
        $interviewer = $this->makeInterviewer();
        $interviewer->askQuestions();
    }
}
```

现在，任何子类都可扩展它并提供所需要的面试官

```php
class DevelopmentManager extends HiringManager
{
    protected function makeInterviewer(): Interviewer
    {
        return new Developer();
    }
}

class MarketingManager extends HiringManager
{
    protected function makeInterviewer(): Interviewer
    {
        return new CommunityExecutive();
    }
}
```

这样用

```php
$devManager = new DevelopmentManager();
$devManager->takeInterview(); // Output: Asking about design patterns

$marketingManager = new MarketingManager();
$marketingManager->takeInterview(); // Output: Asking about community building.
```

**啥时候用呢？**

当类中有一些通用处理但所需的子类在运行时动态确定时很有用。或者换句话说，用户不知道它可能需要什么确切的子类。

### 🔨 抽象工厂

现实例子

> 从简单工厂扩展了我们的门。根据你的需求， 你可能从一家木门店买到一扇门，或者在铁门店买到一扇铁门，或者相关的店买到 PVC 门。另外，你可能需要一个具有不同专业技能的人来安装不同的门，例如，木门的木匠，铁门的焊接工等。如你所见，现在门之间存在依赖性，木门需要木匠，铁门需要焊接工等。

简而言之

> 工厂的工厂；一个将相关或从属的工厂分组在一起，但不指定其具体类别的工厂。

维基说

> 抽象工厂模式提供了一种方法来封装一组具有共同主题的单个工厂，而无需指定其具体类。

**程序示例**

转换上面门的例子。首先我们有门的接口何其实现

```php
interface Door
{
    public function getDescription();
}

class WoodenDoor implements Door
{
    public function getDescription()
    {
        echo 'I am a wooden door';
    }
}

class IronDoor implements Door
{
    public function getDescription()
    {
        echo 'I am an iron door';
    }
}
```

然后我们为每种门配备一些装修专家

```php
interface DoorFittingExpert
{
    public function getDescription();
}

class Welder implements DoorFittingExpert
{
    public function getDescription()
    {
        echo 'I can only fit iron doors';
    }
}

class Carpenter implements DoorFittingExpert
{
    public function getDescription()
    {
        echo 'I can only fit wooden doors';
    }
}
```

现在我们有了抽象工厂，它将使我们能够制造一系列对象，即木门工厂将创建木门和木门配件专家，铁门工厂将创建铁门和铁门配件专家。

```php
interface DoorFactory
{
    public function makeDoor(): Door;
    public function makeFittingExpert(): DoorFittingExpert;
}

// 木门工厂返回木匠和木门
class WoodenDoorFactory implements DoorFactory
{
    public function makeDoor(): Door
    {
        return new WoodenDoor();
    }

    public function makeFittingExpert(): DoorFittingExpert
    {
        return new Carpenter();
    }
}

// 铁门工厂返回铁门和相关的装配专家
class IronDoorFactory implements DoorFactory
{
    public function makeDoor(): Door
    {
        return new IronDoor();
    }

    public function makeFittingExpert(): DoorFittingExpert
    {
        return new Welder();
    }
}
```

接着这么用

```php
$woodenFactory = new WoodenDoorFactory();

$door = $woodenFactory->makeDoor();
$expert = $woodenFactory->makeFittingExpert();

$door->getDescription();  // Output: I am a wooden door
$expert->getDescription(); // Output: I can only fit wooden doors

// Same for Iron Factory
$ironFactory = new IronDoorFactory();

$door = $ironFactory->makeDoor();
$expert = $ironFactory->makeFittingExpert();

$door->getDescription();  // Output: I am an iron door
$expert->getDescription(); // Output: I can only fit iron doors
```

如你所见，木门工厂已经封装了木匠（carpenter）和木门（wooden door），铁门工厂已经封装了铁门（iron door）和焊接工（welder）。因此，它帮助我们确保对于每个已创建的门不会遇到错误的装配专家。

**啥时候用呢?**

当存在相互关联的依赖关系并且涉及到不简单的创建逻辑时。

### 👷 建造者

显示例子

> 加入你在 Hardee 店里下了一笔订单，他们会毫无疑问的将货品交给你；这是简单工厂的例子。但是某些情况下，创建逻辑可能设计更多的步骤。例如，你想要定制赛百味的订单，在汉堡的制作方式上有多种选择，例如：你想要哪种面包？想要那种调味料？那种奶酪？等等。这种情况下，建造者模式应运而生。

简而言之

> 允许你创建对象的不同样式，同时避免构造函数污染。当一个对象有多种风格时很有用，亦或者创建对象涉及很多步骤时。

维基说

> 建造者模式是一种对象创建软件设计模式，旨在为伸缩构造器反模式找到解决方案。

解释一下什么是伸缩构造器反模式。有时我们见过以下构造函数：

```php
public function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce = true)
{
}
```

如你所见，构造函数参数的数量很快会失控，过多的参数看着会很头大。另外，如果你想添加更多选项，则此参数列表还继续增长。这就是伸缩构造函数反模式。

**程序示例**

明智的做法是使用构造器模式。首先，我们要做汉堡

```php
class Burger
{
    protected $size;

    protected $cheese = false;
    protected $pepperoni = false;
    protected $lettuce = false;
    protected $tomato = false;

    public function __construct(BurgerBuilder $builder)
    {
        $this->size = $builder->size;
        $this->cheese = $builder->cheese;
        $this->pepperoni = $builder->pepperoni;
        $this->lettuce = $builder->lettuce;
        $this->tomato = $builder->tomato;
    }
}
```

接着是我们的建造者


```php
class BurgerBuilder
{
    public $size;

    public $cheese = false;
    public $pepperoni = false;
    public $lettuce = false;
    public $tomato = false;

    public function __construct(int $size)
    {
        $this->size = $size;
    }

    public function addPepperoni()
    {
        $this->pepperoni = true;
        return $this;
    }

    public function addLettuce()
    {
        $this->lettuce = true;
        return $this;
    }

    public function addCheese()
    {
        $this->cheese = true;
        return $this;
    }

    public function addTomato()
    {
        $this->tomato = true;
        return $this;
    }

    public function build(): Burger
    {
        return new Burger($this);
    }
}
```

这么用

```php
$burger = (new BurgerBuilder(14))
                    ->addPepperoni()
                    ->addLettuce()
                    ->addTomato()
                    ->build();
```

**啥时候用呢？**

当对象的配置项过多，为了避免伸缩构造函数是，这与工厂模式的主要区别在于：当创建是一步过程时，使用工厂模式，而创建是多步过程是，将使用建造者模式。

### 🐑 原型

现实例子

> 记得多利吗？那只克隆羊！不谈细节，关键是克隆。

简而言之

> 通过克隆基于现有对象创建对象。

维基说

> 原型模式是软件开发中的一种创建设计模式。当要创建的对象由原型示例确定时使用，该实例被克隆以生成新对象。

简而言之，它使你可以创建现有对象的副本并根据需要对其进行修改，而不必麻烦从头开始创建对象并设置。

**程序实例**

在 PHP 中，用 `clone` 很容易做到

```php
class Sheep
{
    protected $name;
    protected $category;

    public function __construct(string $name, string $category = 'Mountain Sheep')
    {
        $this->name = $name;
        $this->category = $category;
    }

    public function setName(string $name)
    {
        $this->name = $name;
    }

    public function getName()
    {
        return $this->name;
    }

    public function setCategory(string $category)
    {
        $this->category = $category;
    }

    public function getCategory()
    {
        return $this->category;
    }
}
```

克隆方式如下

```php
$original = new Sheep('Jolly');
echo $original->getName(); // Jolly
echo $original->getCategory(); // Mountain Sheep

// Clone and modify what is required
$cloned = clone $original;
$cloned->setName('Dolly');
echo $cloned->getName(); // Dolly
echo $cloned->getCategory(); // Mountain sheep
```

你还可以使用魔法方法 `__clone` 方法修改克隆行为。

**啥时候用呢？**

当需要一个与现有对象相似的对象时，或者与克隆相比创建成本很高。

### 💍 单例

现实例子

> 一个国家一次只能有一位总统。每次接听值班电话的都是同一位总统。总统在这里就是单例。

简而言之

> 确保仅创建特定类的一个对象。

维基说

> 在软件工程中，单例模式时一种将类的实例化限制为一个对象的软件设计模式。当仅需要一个对象来协调整个系统中的动作时，这很有用。

单例模式实际上被认为是反模式，应避免过度使用它。它不一定是坏的，并且可能有一些有效的使用场景但是应谨慎使用，因为它会在你的应用程序中引入全局状态，并且在同一个位置进行更改可能会影响其他区域，这让调试变得非常困难。关于它们的另一个不好的地方是，它会使你的代码高耦合，难以模拟单例。

**程序示例**

要创建单例，请将构造函数设为私有，禁用克隆，禁用扩展，并创建一个静态变量来容纳实例。

```php
final class President
{
    private static $instance;

    private function __construct()
    {
        // Hide the constructor
    }

    public static function getInstance(): President
    {
        if (!self::$instance) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    private function __clone()
    {
        // Disable cloning
    }

    private function __wakeup()
    {
        // Disable unserialize
    }
}
```

接着是使用

```php
$president1 = President::getInstance();
$president2 = President::getInstance();

var_dump($president1 === $president2); // true
```

