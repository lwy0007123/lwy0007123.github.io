---
title: 通俗设计模式（译）2
date: 2020-04-25 10:57:17
tags:
- translation
- design pattern
---

[原文：Design Patterns for Humans](https://roadmap.sh/guides/design-patterns-for-humans)

接上一篇，本章关于行为设计模式。

<!--more-->

## 行为设计模式

简而言之

> 它与对象之间的职责分配有关。它们与结构模式的不同之处在于它们不仅指定结构，而且还概述了它们之间消息传递/通信的模式。换句话说，它们是为了解决如何在软件组件中运行一种行为的问题。

维基说

> 软件工程中，行为设计模式是识别对象之间常见的通信模式并实现这些模式的设计模式。这样做提高了执行此通信的灵活性。

下面列出 10 种行为设计模式：

- [Chain of Responsibility 责任链](#🔗-责任链)
- [Command 命令](#👮-命令)
- [Iterator 迭代器](#➿-迭代器)
- [Mediator 调解员](#👽-调解员)
- [Memento 记忆](#💾-记忆)
- [Observer 观察者](#😎-观察者)
- [Visitor 访问者](#🏃-访问者)
- [Strategy 策略](#💡-策略)
- [State 声明](#💢-状态)
- [Template Method 模板方法](#📒-模板方法)

### 🔗 责任链

现实例子

> 如果，你的账号有三种支付方式（A，B 和 C)；每个账号都有不同的存款。 A 有 100 元， B 有 300 元 和 C 有 1000 元，支付偏好的顺序依次为 A、B、C 。你将支付以捡 210 元的商品。用上责任链，首先会检查账户 A 够不够支付，如果可以，将进行购买，然后链条断裂。如果不够，则请求会进一步到账户 B ，检查是否够支付，如果可以，将进行购买，然后链条断裂。否则请求继续直到找到何时的处理程序为止。在这里，A、B 和 C 是链上的链接，整个现象就是责任链。

简而言之

> 它有助于构建对象链。请求从一端进入，并不断地从一个对象移到另一个对象，直到找到合适地处理程序为止。

维基说

> 面向对象设计中，责任链模式是一种设计模式，由命令对象的源和一系列处理对象组成。每个处理对象都包含定义其可以处理的命令对象类型的逻辑；其余的将传递到链中的下一个处理对象。

**程序示例**

用上账户的例子。首先，我们有一个基本账户，该账户具有账户和某些账户链接在一起的逻辑。

```php
abstract class Account
{
    protected $successor;
    protected $balance;

    public function setNext(Account $account)
    {
        $this->successor = $account;
    }

    public function pay(float $amountToPay)
    {
        if ($this->canPay($amountToPay)) {
            echo sprintf('Paid %s using %s' . PHP_EOL, $amountToPay, get_called_class());
        } elseif ($this->successor) {
            echo sprintf('Cannot pay using %s. Proceeding ..' . PHP_EOL, get_called_class());
            $this->successor->pay($amountToPay);
        } else {
            throw new Exception('None of the accounts have enough balance');
        }
    }

    public function canPay($amount): bool
    {
        return $this->balance >= $amount;
    }
}

class Bank extends Account
{
    protected $balance;

    public function __construct(float $balance)
    {
        $this->balance = $balance;
    }
}

class Paypal extends Account
{
    protected $balance;

    public function __construct(float $balance)
    {
        $this->balance = $balance;
    }
}

class Bitcoin extends Account
{
    protected $balance;

    public function __construct(float $balance)
    {
        $this->balance = $balance;
    }
}
```

现在，使用上面定义的链接（即银行、PayPal、比特币）准备链。

```php
// 准备这样一条链
//      $bank->$paypal->$bitcoin
//
// 最开始是银行
//      如果银行不够就尝试 PayPal
//     如果 PayPal 不够再尝试 bit coin

$bank = new Bank(100);          // 银行余额 100
$paypal = new Paypal(200);      // Paypal 余额为 200
$bitcoin = new Bitcoin(300);    // Bitcoin 余额为 300

$bank->setNext($paypal);
$paypal->setNext($bitcoin);

// Let's try to pay using the first priority i.e. bank
$bank->pay(259);

// Output will be
// ==============
// Cannot pay using bank. Proceeding ..
// Cannot pay using paypal. Proceeding ..:
// Paid 259 using Bitcoin!
```

### 👮 命令

现实例子

> 一个通用的例子是你在餐厅点餐。你（即客户）要求服务员（即调用者）带来一些食物（即命令），服务员只需将请求转发给负责烹饪的厨师（即接收者）。另一个例子是，你（即客户）使用遥控器（即调用者）打开（即命令）电视（即接收者）。

简而言之

> 允许你将动作封装在对象中。该模式的关键思想是提供使客户端和接收者解耦的方法。

维基说

> 面向对象编程中，命令模式是一种行为设计模式，其中的对象用于封装以后执行动作或触发事件所需的所有信息。该信息包括方法名称，拥有方法的对象和方法参数的值。

**程序示例**

首先实现接收者的所有动作

```php
// Receiver
class Bulb
{
    public function turnOn()
    {
        echo "Bulb has been lit";
    }

    public function turnOff()
    {
        echo "Darkness!";
    }
}
```

然后我们将接口的每一个命令都实现

```php
interface Command
{
    public function execute();
    public function undo();
    public function redo();
}

// Command
class TurnOn implements Command
{
    protected $bulb;

    public function __construct(Bulb $bulb)
    {
        $this->bulb = $bulb;
    }

    public function execute()
    {
        $this->bulb->turnOn();
    }

    public function undo()
    {
        $this->bulb->turnOff();
    }

    public function redo()
    {
        $this->execute();
    }
}

class TurnOff implements Command
{
    protected $bulb;

    public function __construct(Bulb $bulb)
    {
        $this->bulb = $bulb;
    }

    public function execute()
    {
        $this->bulb->turnOff();
    }

    public function undo()
    {
        $this->bulb->turnOn();
    }

    public function redo()
    {
        $this->execute();
    }
}
```

接着我们的调用者，客户端将与之交互以处理任何命令。

```php
// Invoker
class RemoteControl
{
    public function submit(Command $command)
    {
        $command->execute();
    }
}
```

最后看看客户端中如何使用

```php
$bulb = new Bulb();

$turnOn = new TurnOn($bulb);
$turnOff = new TurnOff($bulb);

$remote = new RemoteControl();
$remote->submit($turnOn); // Bulb has been lit!
$remote->submit($turnOff); // Darkness!
```

命令模式可以用来实现基于事务的系统。一旦执行命令，便会继续保持命令的历史记录。如果最终的命令被成功执行，要么一切正常否则只需要便利历史记录并继续对所有已执行的命令执行撤销即可。

### ➿ 迭代器

现实例子

> 旧收音机的例子挺不错，用户可以从某个频道开始，然后使用下一个或者上一个按钮浏览各个频道。又或者是 MP3 播放器或者电视机也可以通过前后按钮浏览内容，换句话说它们都提供了一个接口，以循环的方式访问相应的频道，歌曲或广播电台。

简而言之

> 它提供了一种在不暴露底层实现的情况下访问对象元素的方法。

维基说

> 面向对象编程中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。迭代器模式将算法与容器解耦；在某些情况下，算法必然特定于容器，因此无法解耦。

**程序示例**

在 PHP 中使用 SPL （标准库） 很容易实现。转换上面电台的例子，首先设计电台类。

```php
class RadioStation
{
    protected $frequency;

    public function __construct(float $frequency)
    {
        $this->frequency = $frequency;
    }

    public function getFrequency(): float
    {
        return $this->frequency;
    }
}
```

然后实现迭代器

```php
use Countable;
use Iterator;

class StationList implements Countable, Iterator
{
    /** @var RadioStation[] $stations */
    protected $stations = [];

    /** @var int $counter */
    protected $counter;

    public function addStation(RadioStation $station)
    {
        $this->stations[] = $station;
    }

    public function removeStation(RadioStation $toRemove)
    {
        $toRemoveFrequency = $toRemove->getFrequency();
        $this->stations = array_filter($this->stations, function (RadioStation $station) use ($toRemoveFrequency) {
            return $station->getFrequency() !== $toRemoveFrequency;
        });
    }

    public function count(): int
    {
        return count($this->stations);
    }

    public function current(): RadioStation
    {
        return $this->stations[$this->counter];
    }

    public function key()
    {
        return $this->counter;
    }

    public function next()
    {
        $this->counter++;
    }

    public function rewind()
    {
        $this->counter = 0;
    }

    public function valid(): bool
    {
        return isset($this->stations[$this->counter]);
    }
}
```

这么用

```php
$stationList = new StationList();

$stationList->addStation(new RadioStation(89));
$stationList->addStation(new RadioStation(101));
$stationList->addStation(new RadioStation(102));
$stationList->addStation(new RadioStation(103.2));

foreach($stationList as $station) {
    echo $station->getFrequency() . PHP_EOL;
}

$stationList->removeStation(new RadioStation(89)); // Will remove station 89
```

### 👽 调解员

现实例子

> 一个一般的例子，当你与其他人通过手机通话时，对话消息是通过网络提供商发送过去的。这里网络提供商就是调解员。

简而言之

> 调解员模式添加了第三方对象（称作调解员）用于控制两个对象（称作同事）之间的交互。它有助于减少彼此通信的类之间的耦合。因为他们不需要了解彼此的实现。

维基说

> 软件工程中，调解员模式定义了一个对象，该对象封装了一组对象的交互方式。由于该模式可以更改程序运行行为，因此该模式被视为行为模式。

**程序示例**

这是一个简单的聊天室（即调解员）中的用户（即同事）互相发消息的例子。

首先，实现调解员接口，即聊天室。

```php
interface ChatRoomMediator 
{
    public function showMessage(User $user, string $message);
}

// Mediator
class ChatRoom implements ChatRoomMediator
{
    public function showMessage(User $user, string $message)
    {
        $time = date('M d, y H:i');
        $sender = $user->getName();

        echo $time . '[' . $sender . ']:' . $message;
    }
}
```

然后是用户，即同事

```php
class User {
    protected $name;
    protected $chatMediator;

    public function __construct(string $name, ChatRoomMediator $chatMediator) {
        $this->name = $name;
        $this->chatMediator = $chatMediator;
    }

    public function getName() {
        return $this->name;
    }

    public function send($message) {
        $this->chatMediator->showMessage($this, $message);
    }
}
```

用例

```php
$mediator = new ChatRoom();

$john = new User('John Doe', $mediator);
$jane = new User('Jane Doe', $mediator);

$john->send('Hi there!');
$jane->send('Hey!');

// Output will be
// Feb 14, 10:58 [John]: Hi there!
// Feb 14, 10:58 [Jane]: Hey!
```

### 💾 记忆

现实例子

> 举一个计算器的例子，计算器（即 originator ）在这里每执行一些运算，最后的结果都会保存在内存中（即记忆），以便你返回它，还可以用某些操作按钮（即看守者）将其恢复。

简而言之

> 记忆模式是关于捕获和存储对象的当前状态的方式，以便之后可以平滑地恢复它。

维基说

> 记忆模式是一种软件设计模式，它提供了将对象恢复到其先前状态（回滚撤销）的能力。

通常在需要提供某种撤销功能时很有用。

**程序示例**

我们以文本编辑器为例，该编辑器不时保存状态，并可以根据需要进行恢复。

首先是保存编辑器状态的记忆对象。

```php
class EditorMemento
{
    protected $content;

    public function __construct(string $content)
    {
        $this->content = $content;
    }

    public function getContent()
    {
        return $this->content;
    }
}
```

接着我们的编辑器，即 originator ，将要使用这个记忆对象。

```php
class Editor
{
    protected $content = '';

    public function type(string $words)
    {
        $this->content = $this->content . ' ' . $words;
    }

    public function getContent()
    {
        return $this->content;
    }

    public function save()
    {
        return new EditorMemento($this->content);
    }

    public function restore(EditorMemento $memento)
    {
        $this->content = $memento->getContent();
    }
}
```

接着这么用

```php
$editor = new Editor();

// Type some stuff
$editor->type('This is the first sentence.');
$editor->type('This is second.');

// Save the state to restore to : This is the first sentence. This is second.
$saved = $editor->save();

// Type some more
$editor->type('And this is third.');

// Output: Content before Saving
echo $editor->getContent(); // This is the first sentence. This is second. And this is third.

// Restoring to last saved state
$editor->restore($saved);

$editor->getContent(); // This is the first sentence. This is second.
```






### 😎 观察者

现实例子

> 找工作的人在职位发布网站上订阅，获得匹配的工作机会时，他们可以收到消息。

简而言之

> 定义对象之间的依赖关系，以便每当对象改变状态时，都会通知其所有依赖对象。

维基说

> 观察者模式是一种软件设计模式，其中对象（称为主题）维护其依赖项的列表（称为观察者），并通过调用其方法来自动将状态更改通知他们。

**程序示例**

实现上面的例子，首先，需要发布通知给求职者。

```php
class JobPost
{
    protected $title;

    public function __construct(string $title)
    {
        $this->title = $title;
    }

    public function getTitle()
    {
        return $this->title;
    }
}

class JobSeeker implements Observer
{
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function onJobPosted(JobPost $job)
    {
        // Do something with the job posting
        echo 'Hi ' . $this->name . '! New job posted: '. $job->getTitle();
    }
}
```

然后求职者将订阅职位消息

```php
class EmploymentAgency implements Observable
{
    protected $observers = [];

    protected function notify(JobPost $jobPosting)
    {
        foreach ($this->observers as $observer) {
            $observer->onJobPosted($jobPosting);
        }
    }

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function addJob(JobPost $jobPosting)
    {
        $this->notify($jobPosting);
    }
}
```

用例

```php
// Create subscribers
$johnDoe = new JobSeeker('John Doe');
$janeDoe = new JobSeeker('Jane Doe');

// Create publisher and attach subscribers
$jobPostings = new EmploymentAgency();
$jobPostings->attach($johnDoe);
$jobPostings->attach($janeDoe);

// Add a new job and see if subscribers get notified
$jobPostings->addJob(new JobPost('Software Engineer'));

// Output
// Hi John Doe! New job posted: Software Engineer
// Hi Jane Doe! New job posted: Software Engineer

```

### 🏃 访问者

实际例子

> 加入有人要去迪拜旅游，他们需要一种进入迪拜的方式（即签证）。抵达之后，他们可以独自前往迪拜的任何地方，而不需要跑腿搞许可证；只要告诉他们地名，就可以去参观。访问者模式让你做到这一点，它可以帮助你添加游览的地点，以便他们可以尽可能多访问而不需要做任何繁琐的工作。

简而言之

> 访问者模式使你可以给对象添加进一步的操作，而无需修改它们。

维基说

> 在面向对象程序设计中，访问者设计模式时一种将算法和操作对象的结构分离的方法。这种分离的实际结果是能够在不修改这些对象结构的情况下向现有对象结构添加新操作。这是遵循开闭原则（Open Closed Principle）的一种方法。

**程序示例**

我们来模拟一所动物园，其中有几种不同的动物，我们必须赋予它们声音。下面用访问者模式来实现它。

```php
// Visitee
interface Animal
{
    public function accept(AnimalOperation $operation);
}

// Visitor
interface AnimalOperation
{
    public function visitMonkey(Monkey $monkey);
    public function visitLion(Lion $lion);
    public function visitDolphin(Dolphin $dolphin);
}
```

实现这些动物

```php
class Monkey implements Animal
{
    public function shout()
    {
        echo 'Ooh oo aa aa!';
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitMonkey($this);
    }
}

class Lion implements Animal
{
    public function roar()
    {
        echo 'Roaaar!';
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitLion($this);
    }
}

class Dolphin implements Animal
{
    public function speak()
    {
        echo 'Tuut tuttu tuutt!';
    }

    public function accept(AnimalOperation $operation)
    {
        $operation->visitDolphin($this);
    }
}
```

实现访问者

```php
class Speak implements AnimalOperation
{
    public function visitMonkey(Monkey $monkey)
    {
        $monkey->shout();
    }

    public function visitLion(Lion $lion)
    {
        $lion->roar();
    }

    public function visitDolphin(Dolphin $dolphin)
    {
        $dolphin->speak();
    }
}
```

这样用

```php
$monkey = new Monkey();
$lion = new Lion();
$dolphin = new Dolphin();

$speak = new Speak();

$monkey->accept($speak);    // Ooh oo aa aa!    
$lion->accept($speak);      // Roaaar!
$dolphin->accept($speak);   // Tuut tutt tuutt!
```

我们可以通过对动物具有继承层次结构来简单地做到这一点，但是每当我们必须向动物添加新动作时，就必须修改动物。但是现在我们不必更改它们。例如：假设我们被要求将跳跃行为添加到动物中，我们可以简单地通过创建一个新的访问者来添加它，即：

```php
class Jump implements AnimalOperation
{
    public function visitMonkey(Monkey $monkey)
    {
        echo 'Jumped 20 feet high! on to the tree!';
    }

    public function visitLion(Lion $lion)
    {
        echo 'Jumped 7 feet! Back on the ground!';
    }

    public function visitDolphin(Dolphin $dolphin)
    {
        echo 'Walked on water a little and disappeared';
    }
}
```

使用

```php
$jump = new Jump();

$monkey->accept($speak);   // Ooh oo aa aa!
$monkey->accept($jump);    // Jumped 20 feet high! on to the tree!

$lion->accept($speak);     // Roaaar!
$lion->accept($jump);      // Jumped 7 feet! Back on the ground!

$dolphin->accept($speak);  // Tuut tutt tuutt!
$dolphin->accept($jump);   // Walked on water a little and disappeared
```

### 💡 策略

现实例子

> 考虑一个排序的例子，我们实现了冒泡排序，但是随着数据的增长，冒泡排序越来越慢。为了解决这个问题，我们实现了快排。但是现在，尽管快速排序算法对大型数据集表现更好，但是对于较小数据集却很慢。为了解决这个问题，我们实现了一种策略，对于小型数据集，使用冒泡排序，而对于较大的使用快排。

简而言之

> 策略模式可以根据情况切换算法或策略。

维基说

> 在计算机编程中，策略（strategy）模式（也称为策略（policy）模式）是一种行为设计模式，可以在运行时选择算法行为。

**程序示例**

首先对我们测策略接口做出不同实现。

```php
interface SortStrategy
{
    public function sort(array $dataset): array;
}

class BubbleSortStrategy implements SortStrategy
{
    public function sort(array $dataset): array
    {
        echo "Sorting using bubble sort";

        // Do sorting
        return $dataset;
    }
}

class QuickSortStrategy implements SortStrategy
{
    public function sort(array $dataset): array
    {
        echo "Sorting using quick sort";

        // Do sorting
        return $dataset;
    }
}
```

然后客户可以使用任意策略

```php
class Sorter
{
    protected $sorter;

    public function __construct(SortStrategy $sorter)
    {
        $this->sorter = $sorter;
    }

    public function sort(array $dataset): array
    {
        return $this->sorter->sort($dataset);
    }
}
```

用法

```php
$dataset = [1, 5, 4, 3, 2, 8];

$sorter = new Sorter(new BubbleSortStrategy());
$sorter->sort($dataset); // Output : Sorting using bubble sort

$sorter = new Sorter(new QuickSortStrategy());
$sorter->sort($dataset); // Output : Sorting using quick sort
```

### 💢 状态

实际例子

> 假设你正在使用某些绘图程序，绘画时选择画笔。现在，画笔将根据所选颜色更改其行为，即如果选择红色，它将绘制为红色，选择蓝色，则将绘制为蓝色等。

简而言之

> 当状态改变时，它允许你改变类的行为。

维基说

> 状态模式是一种行为软件设计模式，它以面向对象的方式实现状态机。使用状态模式，通过将每个单独的状态实现为状态模式接口的派生类，并通过调用模式的超类所定义的方法来实现状态转换。状态模式可以解释为策略模式，该模式能够通过调用模式接口中定义的方法来切换当前策略。

**程序示例**

再用文本编辑器的例子，它使你可以改变键入文本的状态，选择斜体，将以斜体显示；如果选择粗体，将以粗体显示。

首先是状态接口及其实现。

```php
interface WritingState
{
    public function write(string $words);
}

class UpperCase implements WritingState
{
    public function write(string $words)
    {
        echo strtoupper($words);
    }
}

class LowerCase implements WritingState
{
    public function write(string $words)
    {
        echo strtolower($words);
    }
}

class DefaultText implements WritingState
{
    public function write(string $words)
    {
        echo $words;
    }
}
```

接着是编辑器

```php
class TextEditor
{
    protected $state;

    public function __construct(WritingState $state)
    {
        $this->state = $state;
    }

    public function setState(WritingState $state)
    {
        $this->state = $state;
    }

    public function type(string $words)
    {
        $this->state->write($words);
    }
}
```

使用

```php
$editor = new TextEditor(new DefaultText());

$editor->type('First line');

$editor->setState(new UpperCase());

$editor->type('Second line');
$editor->type('Third line');

$editor->setState(new LowerCase());

$editor->type('Fourth line');
$editor->type('Fifth line');

// Output:
// First line
// SECOND LINE
// THIRD LINE
// fourth line
// fifth line
```

### 📒 模板方法

实际例子

> 假设我们要造房子，构建步骤可能如下：
> - 打地基
> - 砌墙
> - 加屋顶
> - 添加其他楼层
>
> 这些步骤的顺序是不会改变的，即你不可以在砌墙之前盖屋顶，但是每个步骤可以修改，例如墙壁可以由木头、聚酯或石头制成。

简而言之

> 模板方法定义了如何执行某种算法的框架，但是将这些步骤的实现交给字类。

维基说

> 软件工程领域，模板方法模式是一种行为设计模式，用于定义操作中算法的程序框架，从而将某些步骤推迟到子类中。

**程序示例**

设想我们有一个构建工具可以帮助我们测试、整理、构建，生成报告（即覆盖率报告，lint 报告等）并且将我们的程序部署在测试服务器上。

首先，搭建基类，它指定构建算法的框架。

```php
abstract class Builder
{
    // Template method
    final public function build()
    {
        $this->test();
        $this->lint();
        $this->assemble();
        $this->deploy();
    }

    abstract public function test();
    abstract public function lint();
    abstract public function assemble();
    abstract public function deploy();
}
```

实现接口

```php
class AndroidBuilder extends Builder
{
    public function test()
    {
        echo 'Running android tests';
    }

    public function lint()
    {
        echo 'Linting the android code';
    }

    public function assemble()
    {
        echo 'Assembling the android build';
    }

    public function deploy()
    {
        echo 'Deploying android build to server';
    }
}

class IosBuilder extends Builder
{
    public function test()
    {
        echo 'Running ios tests';
    }

    public function lint()
    {
        echo 'Linting the ios code';
    }

    public function assemble()
    {
        echo 'Assembling the ios build';
    }

    public function deploy()
    {
        echo 'Deploying ios build to server';
    }
}
```

用法

```php
$androidBuilder = new AndroidBuilder();
$androidBuilder->build();

// Output:
// Running android tests
// Linting the android code
// Assembling the android build
// Deploying android build to server

$iosBuilder = new IosBuilder();
$iosBuilder->build();

// Output:
// Running ios tests
// Linting the ios code
// Assembling the ios build
// Deploying ios build to server
```

## 最后

到此为止。我将继续对此进行改进，你可以 watch/star 这个[仓库](https://github.com/kamranahmedse/developer-roadmap/)。之后计划编写有关架构模式的文章，敬请期待。
